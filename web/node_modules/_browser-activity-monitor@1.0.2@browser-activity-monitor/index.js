"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var eventemitter2_1 = require("eventemitter2");
var DEFAULT_OPTIONS = {
    inactivityThreshold: 5 * 60 * 1000
};
// TODO: Use ES6 Symbols (pending https://github.com/asyncly/EventEmitter2/issues/201)
exports.ACTIVE = 'ACTIVE';
exports.INACTIVE = 'INACTIVE';
var ActivityMonitor = (function (_super) {
    __extends(ActivityMonitor, _super);
    function ActivityMonitor(document, options) {
        if (options === void 0) { options = DEFAULT_OPTIONS; }
        var _this = _super.call(this) || this;
        _this.document = document;
        _this.options = options;
        _this._onVisibilityChange = _this.onVisibilityChange.bind(_this);
        _this.state = {
            hidden: undefined,
            timer: undefined
        };
        if (!('hidden' in document)) {
            throw new Error('ActivityMonitor does not support this browser. List of suppprted browsers: http://caniuse.com/#feat=pagevisibility');
        }
        _this.state.hidden = document.hidden;
        document.addEventListener('visibilitychange', _this._onVisibilityChange, false);
        return _this;
    }
    ActivityMonitor.prototype.destroy = function () {
        this.document.removeEventListener('visibilitychange', this._onVisibilityChange);
    };
    ActivityMonitor.prototype.onVisibilityChange = function () {
        var _this = this;
        if (this.state.hidden === this.document.hidden) {
            return;
        }
        // set an inactivity timer, announce inactivity after
        // the timer is elapsed (unless the timer gets cancelled)
        if (this.document.hidden) {
            this.state.hidden = true;
            this.state.timer = setTimeout(function () {
                _this.emit(exports.INACTIVE);
                _this.state.timer = undefined;
            }, this.options.inactivityThreshold);
            return;
        }
        // cancel inactivity timer
        if (this.state.timer) {
            clearTimeout(this.state.timer);
            this.state.timer = undefined;
            return;
        }
        // only emit active stage if it's a transition from
        // inactive -> active
        this.emit(exports.ACTIVE);
        this.state.hidden = false;
    };
    return ActivityMonitor;
}(eventemitter2_1.EventEmitter2));
exports.ActivityMonitor = ActivityMonitor;
//# sourceMappingURL=index.js.map